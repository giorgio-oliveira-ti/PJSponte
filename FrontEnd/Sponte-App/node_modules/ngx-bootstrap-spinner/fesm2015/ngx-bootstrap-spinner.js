import { ɵɵdefineInjectable, Injectable, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, Input, Pipe, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { DomSanitizer } from '@angular/platform-browser';

const DEFAULTS = {
    BD_COLOR: 'rgba(51,51,51,0.8)',
    SPINNER_COLOR: '#fff',
    SPINNER_TYPE: 'border',
    Z_INDEX: 99999,
};
const PRIMARY_SPINNER = 'primary';
class NgxSpinner {
    constructor(init) {
        Object.assign(this, init);
    }
}

class NgxSpinnerService {
    /**
     * Creates an instance of NgxSpinnerService.
     * @memberof NgxSpinnerService
     */
    constructor() {
        /**
         * Spinner observable
         *
         * @memberof NgxSpinnerService
         */
        // private spinnerObservable = new ReplaySubject<NgxSpinner>(1);
        this.spinnerObservable = new BehaviorSubject(null);
    }
    /**
    * Get subscription of desired spinner
    * @memberof NgxSpinnerService
    **/
    getSpinner(name) {
        return this.spinnerObservable.asObservable().pipe(filter((x) => x && x.name === name));
    }
    /**
     * To show spinner
     *
     * @memberof NgxSpinnerService
     */
    show(name = PRIMARY_SPINNER, spinner) {
        setTimeout(() => {
            const showPromise = new Promise((resolve, _reject) => {
                if (spinner && Object.keys(spinner).length) {
                    spinner['name'] = name;
                    this.spinnerObservable.next(new NgxSpinner(Object.assign(Object.assign({}, spinner), { show: true })));
                    resolve(true);
                }
                else {
                    this.spinnerObservable.next(new NgxSpinner({ name, show: true }));
                    resolve(true);
                }
            });
            return showPromise;
        }, 10);
    }
    /**
    * To hide spinner
    *
    * @memberof NgxSpinnerService
    */
    hide(name = PRIMARY_SPINNER, debounce = 10) {
        setTimeout(() => {
            const hidePromise = new Promise((resolve, _reject) => {
                this.spinnerObservable.next(new NgxSpinner({ name, show: false }));
                resolve(true);
            });
            return hidePromise;
        }, debounce);
    }
}
NgxSpinnerService.ɵprov = ɵɵdefineInjectable({ factory: function NgxSpinnerService_Factory() { return new NgxSpinnerService(); }, token: NgxSpinnerService, providedIn: "root" });
NgxSpinnerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NgxSpinnerService.ctorParameters = () => [];

// import { trigger, state, style, transition, animate } from '@angular/animations';
class NgxSpinnerComponent {
    /**
     * Creates an instance of NgxSpinnerComponent.
     *
     * @memberof NgxSpinnerComponent
     */
    constructor(spinnerService, changeDetector, elementRef) {
        this.spinnerService = spinnerService;
        this.changeDetector = changeDetector;
        this.elementRef = elementRef;
        /**
         * button Spinner.
         * https://getbootstrap.com/docs/4.4/components/spinners/#buttons
         *
         * @memberof NgxSpinnerComponent
         *
         */
        this.isButtonSpinner = false;
        /**
         * isButtonSpinner is true and when the spinner shown,the button disabled set to true
         *
         * @memberof NgxSpinnerComponent
         *
         */
        this.autoDisableButton = false;
        /**
         * Spinner Object
         *
         * @memberof NgxSpinnerComponent
         */
        this.spinner = new NgxSpinner();
        /**
         * Unsubscribe from spinner's observable
         *
         * @memberof NgxSpinnerComponent
        **/
        this.ngUnsubscribe = new Subject();
        /**
         * To set default ngx-spinner options
         *
         * @memberof NgxSpinnerComponent
         */
        this.setDefaultOptions = () => {
            this.spinner = new NgxSpinner({
                name: this.name,
                bdColor: this.bdColor,
                size: this.size,
                color: this.color,
                type: this.type,
                fullScreen: this.fullScreen,
                show: this.show,
                zIndex: this.zIndex,
                loaderTemplate: this.loaderTemplate,
                loadingTextTemplate: this.loadingTextTemplate,
                autoDisableButton: this.autoDisableButton
            });
        };
        this.bdColor = DEFAULTS.BD_COLOR;
        this.zIndex = DEFAULTS.Z_INDEX;
        this.color = DEFAULTS.SPINNER_COLOR;
        this.type = DEFAULTS.SPINNER_TYPE;
        this.size = 'default';
        this.fullScreen = true;
        this.name = PRIMARY_SPINNER;
        this.loaderTemplate = null;
        this.show = false;
    }
    /**
     * Initialization method
     *
     * @memberof NgxSpinnerComponent
     */
    ngOnInit() {
        this.setDefaultOptions();
        this.spinnerService.getSpinner(this.name).subscribe(x => {
            if (this.isButtonSpinner && this.autoDisableButton) {
                let button = this.elementRef.nativeElement.closest("button");
                button.disabled = x.show;
            }
        });
        this.spinnerService.getSpinner(this.name)
            .pipe(takeUntil(this.ngUnsubscribe))
            .subscribe((spinner) => {
            this.setDefaultOptions();
            Object.assign(this.spinner, spinner);
            if (spinner.show) {
                this.onInputChange();
            }
            this.changeDetector.markForCheck();
        });
    }
    /**
     * On changes event for input variables
     *
     * @memberof NgxSpinnerComponent
     */
    ngOnChanges(changes) {
        for (const propName in changes) {
            if (propName) {
                const changedProp = changes[propName];
                if (changedProp.isFirstChange()) {
                    return;
                }
                else if (typeof changedProp.currentValue !== 'undefined' && changedProp.currentValue !== changedProp.previousValue) {
                    if (changedProp.currentValue !== '') {
                        this.spinner[propName] = changedProp.currentValue;
                    }
                }
            }
        }
    }
    /**
     * To get class for spinner
     *
     * @memberof NgxSpinnerComponent
     */
    getClass(type, size) {
        let sizeClass = '';
        switch (size.toLowerCase()) {
            case 'small':
                sizeClass = 'sm';
                break;
            default:
                break;
        }
        if (sizeClass == '')
            return ['spinner-' + type];
        else
            return ['spinner-' + type, 'spinner-' + type + '-' + sizeClass];
    }
    /**
     * Check if input variables have changed
     *
     * @memberof NgxSpinnerComponent
     */
    onInputChange() {
        this.spinner.class = this.getClass(this.spinner.type, this.spinner.size);
    }
    /**
     * Component destroy event
     *
     * @memberof NgxSpinnerComponent
     */
    ngOnDestroy() {
        this.ngUnsubscribe.next();
        this.ngUnsubscribe.complete();
    }
}
NgxSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-bootstrap-spinner',
                template: "<div *ngIf=\"!isButtonSpinner&&spinner.show\"\r\n  class=\"overlay d-flex flex-column justify-content-center align-items-center\"\r\n  [style.background-color]=\"spinner.bdColor\" [style.z-index]=\"spinner.zIndex\"\r\n  [style.position]=\"spinner.fullScreen ? 'fixed' : 'absolute'\" [style.color]=\"spinner.color\">\r\n  <ng-container *ngTemplateOutlet=\"loadingTemplate\"></ng-container>\r\n</div>\r\n\r\n<ng-container *ngIf=\"isButtonSpinner&&spinner.show\" [ngTemplateOutlet]=\"loadingTemplate\">\r\n</ng-container>\r\n\r\n<ng-template #loadingTemplate>\r\n  <span *ngIf=\"!loaderTemplate\" [ngClass]=\"spinner.class\" role=\"status\" aria-hidden=\"true\">\r\n    <span class=\"sr-only\">{{loadingText}}</span>\r\n  </span>\r\n  <div *ngIf=\"loaderTemplate\" [innerHTML]=\"loaderTemplate | safeHtml\"></div>\r\n  <div *ngIf=\"!loadingTextTemplate\" [ngClass]=\"{'sr-only': isButtonSpinner,'loading-text':!isButtonSpinner}\">\r\n    {{loadingText}}\r\n  </div>\r\n  {{isButtonSpinner&&!loadingTextTemplate?loadingText:\"\"}}\r\n  <div *ngIf=\"loadingTextTemplate\" [innerHTML]=\"loadingTextTemplate | safeHtml\"></div>\r\n</ng-template>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".overlay{height:100%;left:0;position:fixed;top:0;width:100%}"]
            },] }
];
NgxSpinnerComponent.ctorParameters = () => [
    { type: NgxSpinnerService },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NgxSpinnerComponent.propDecorators = {
    bdColor: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    type: [{ type: Input }],
    fullScreen: [{ type: Input }],
    name: [{ type: Input }],
    zIndex: [{ type: Input }],
    loaderTemplate: [{ type: Input }],
    loadingText: [{ type: Input }],
    loadingTextTemplate: [{ type: Input }],
    isButtonSpinner: [{ type: Input }],
    autoDisableButton: [{ type: Input }]
};

class SafeHtmlPipe {
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    transform(v) {
        if (v) {
            return this._sanitizer.bypassSecurityTrustHtml(v);
        }
    }
}
SafeHtmlPipe.decorators = [
    { type: Pipe, args: [{
                name: 'safeHtml'
            },] }
];
SafeHtmlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

class NgxSpinnerModule {
}
NgxSpinnerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [NgxSpinnerComponent, SafeHtmlPipe],
                exports: [NgxSpinnerComponent]
            },] }
];

/*
 * Public API Surface of ngx-bootstrap-spinner
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxSpinnerComponent, NgxSpinnerModule, NgxSpinnerService, SafeHtmlPipe as ɵa };
//# sourceMappingURL=ngx-bootstrap-spinner.js.map
